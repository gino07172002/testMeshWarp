<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>網格變形圖像動畫編輯軟體</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@3/dist/vue.global.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div id="app">
    <div class="editor-container">
      <!-- 頂部標題列 -->
      <div class="header">
        <div class="menu-bar">
          <div class="menu-item" @click.stop="toggleDropdown('fileDropdown')"> <!-- 添加.stop修飾符 -->
            檔案
            <div class="dropdown-menu" v-show="fileDropdown">
              <div class="dropdown-item" @click="handleFileAction('new')">新增</div>
              <div class="dropdown-item" @click="handleFileAction('open')">開啟</div>
              <div class="dropdown-item" @click="handleFileAction('save')">儲存</div>
              <div class="dropdown-item" @click="handleFileAction('export')">匯出</div>
            </div>
          </div>
          <div class="menu-item" @click="toggleDropdown('editDropdown')">
            編輯
            <div class="dropdown-menu" v-show="editDropdown">
              <div class="dropdown-item" @click="handleEditAction('undo')">復原</div>
              <div class="dropdown-item" @click="handleEditAction('redo')">重做</div>
              <div class="dropdown-item" @click="handleEditAction('cut')">剪下</div>
              <div class="dropdown-item" @click="handleEditAction('copy')">複製</div>
              <div class="dropdown-item" @click="handleEditAction('paste')">貼上</div>
            </div>
          </div>
        </div>
      </div>

      <!-- 主畫面：左側工具列 / 中間畫布區 / 右側圖層面板 -->
      <div class="main-container">
        <!-- 左側工具 -->
        <div class="toolbar">
          <button class="tool-btn" :class="{ active: activeTool === 'grab-point' }" @click="selectTool('grab-point')">grab-point</button>
          <button class="tool-btn" :class="{ active: activeTool === 'bone-create' }" @click="selectTool('bone-create')">bone-create</button>
        </div>

        <!-- 中間畫布 -->
        <div class="canvas-area">
          <div class="image-container" ref="imageContainer">
            <img class="image-canvas" id="main-image" :src="imageData" alt="讀取圖片" @mousedown="handleCanvasMouseDown"
              @mousemove="handleCanvasMouseMove" @mouseup="handleCanvasMouseUp" @contextmenu.prevent>

            <!-- 此覆蓋層用於呈現點擊新增的圓圈 -->
            <div class="overlay-canvas">
              <div v-for="(point, index) in points" :key="index" class="point" :style="{
                  position: 'absolute',
                  width: '10px',
                  height: '10px',
                  borderRadius: '50%',
                  backgroundColor: 'red',
                  left: point.x + 'px',
                  top: point.y + 'px'
                }"></div>
            </div>
          </div>
          <!-- 清除所有點的按鈕 -->
          <button @click="clearPoints" style="position:absolute; top:10px; right:10px; z-index:100;">清除點</button>
        </div>

        <!-- 右側圖層 -->
        <div class="layers-panel">
          <div class="panel-section layers-section" style="height: 200px; flex: 0 0 200px;">
            <div class="panel-title">階層式物件</div>
            <div class="layers-container">
              <div class="tree-item">
                <div class="tree-item-header">
                  <span class="tree-toggle-icon" :class="{ 'expanded': expandedNodes.includes('root') }"
                    @click.stop="toggleNode('root')">▶</span>
                  <span class="tree-item-name" @click.stop="handleNameClick('Root')">Root</span>
                </div>
                <div class="tree-children" v-if="expandedNodes.includes('root')">
                  <div class="tree-item">
                    <div class="tree-item-header">
                      <span class="tree-toggle-icon" :class="{ 'expanded': expandedNodes.includes('child1') }"
                        @click.stop="toggleNode('child1')">▶</span>
                      <span class="tree-item-name" @click.stop="handleNameClick('Child1')">Child1</span>
                    </div>
                    <div class="tree-children" v-if="expandedNodes.includes('child1')">
                      <div class="tree-item">
                        <div class="tree-item-header">
                          <span class="tree-item-name" @click.stop="handleNameClick('GrandChild')">GrandChild</span>
                        </div>
                      </div>
                    </div>
                  </div>
                  <div class="tree-item">
                    <div class="tree-item-header">
                      <span class="tree-item-name" @click.stop="handleNameClick('Child2')">Child2</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>


          <div class="panel-section layers-section" style="height: 400px; flex: 0 0 400px;">
            <div class="panel-title">圖層</div>
            <div class="layers-content">
              <div class="layers-container">
                <div v-for="layer in layers" :key="layer.id" class="layer-item"
                  :class="{ active: layer.id === selectedLayerId }" @click="selectLayer(layer.id)">
                  {{ layer.name }}
                </div>
              </div>
              <div class="layers-actions">
                <button class="layer-btn" @click="addLayer">新增圖層</button>
                <button class="layer-btn" @click="deleteLayer">刪除選中圖層</button>
                <button class="layer-btn" @click="saveLayerToServer">儲存圖層到伺服器</button>
              </div>
            </div>
          </div>
        </div>




      </div>

      <!-- 動畫時間軸 -->
      <div class="timeline">
        <div class="timeline-header">
          <div class="timeline-title">動畫時間軸</div>
          <div class="timeline-controls">
            <button class="timeline-btn" @click="addKeyframe">新增Key點</button>
            <button class="timeline-btn" @click="addTimelineComponent">新增時間軸元件</button>
          </div>
        </div>
        <div class="timeline-content">
          <div class="timeline-layers">
            <div v-for="layer in layers" :key="'timeline-' + layer.id" class="timeline-layer-item">
              {{ layer.name }}
            </div>
          </div>
          <div class="timeline-tracks" ref="timelineTracks" @mousedown="startDrag" @mousemove="onDrag"
            @mouseup="stopDrag" @mouseleave="stopDrag">
            <div v-for="keyframe in keyframes" :key="keyframe.id" class="keyframe"
              :style="{ left: keyframe.position + 'px' }" :title="'Keyframe ' + keyframe.id"
              @click.stop="selectKeyframe(keyframe.id)"></div>
          </div>
        </div>
      </div>

      <!-- 狀態列 -->
      <div class="status-bar">
        <div class="status-item">狀態: {{ status }}</div>
      </div>
    </div>
  </div>

  <script>
    // 創建應用
    const app = Vue.createApp({
      data() {
        return {
          imageData: '',
          lastTimestamp: 0,
          status: '準備中',
          activeTool: null,
          points: [],
          fileDropdown: false,
          editDropdown: false,
          selectedLayerId: null,
          layers: [],
          layerCounter: 0,
          keyframes: [],
          keyframeCounter: 0,
          isDragging: false,
          startX: 0,
          scrollLeft: 0,
          dragStartX: 0,
          dragStartY: 0,
          points: [],
          fileDropdown: false,
          editDropdown: false,
          selectedLayerId: null,
          layers: [],
          layerCounter: 0,
          keyframes: [],
          keyframeCounter: 0,
          isDragging: false,
          startX: 0,
          scrollLeft: 0,
          hierarchicalData: {
            children: [
              {
                children: [
                  {
                    name: "GrandChild"
                  }
                ],
                name: "Child1"
              },
              {
                name: "Child2"
              }
            ],
            name: "Root"
          },
          expandedNodes: []
        };
      },
      mounted() {
        document.addEventListener('click', this.handleClickOutside);
        this.startImageUpdates();
        // 初始化時新增一個預設圖層
        this.addLayer();
      },

      beforeUnmount() {
        clearInterval(this.updateTimer);
      },
      unmounted() {
        document.removeEventListener('click', this.handleClickOutside);
      },
      methods: {

        fetchImage() {
          fetch('/png')
            .then(response => response.json())
            .then(data => {
              // 只有當時間戳記比上次更新時才更新圖片
              if (data.timestamp > this.lastTimestamp) {
                this.imageData = data.image;
                this.lastTimestamp = data.timestamp;
              }
            })
            .catch(error => console.error('圖片載入失敗:', error));
        },
        // 定期更新或在需要時呼叫
        startImageUpdates() {
          this.fetchImage();
          this.updateTimer = setInterval(() => {
            this.fetchImage();
          }, 200); // 每秒更新一次，可調整
        },
        handleCanvasClick(event) {
          // 處理點擊事件...
          // 編輯後可能需要刷新圖片
          this.fetchImage();
        },
        // 關閉其他下拉選單
        closeAllDropdowns() {
          this.fileDropdown = false;
          this.editDropdown = false;
        },

        // 下拉選單切換
        toggleDropdown(dropdown) {
          console.log("hi dropdown ... ");
          this.closeAllDropdowns();
          if (dropdown === 'fileDropdown') {
            console.log("hi?... ");
            this.fileDropdown = !this.fileDropdown;
          } else if (dropdown === 'editDropdown') {
            console.log("hi! ... ");
            this.editDropdown = !this.editDropdown;
          }
        },

        // 處理檔案選單動作
        handleFileAction(action) {
          this.status = `執行檔案動作: ${action}`;
          this.closeAllDropdowns();

          if (action === 'save') {
            this.saveProjectToServer();
          }
        },

        // 處理編輯選單動作
        handleEditAction(action) {
          this.status = `執行編輯動作: ${action}`;
          this.closeAllDropdowns();
        },
        updateImage(newUrl) {
          this.imageUrl = newUrl;
          this.cacheBuster = Date.now(); // 更新 cacheBuster 來強制刷新
        },
        // 選擇工具
        selectTool(tool) {
          console.log(" hi  ", tool);
          this.activeTool = this.activeTool === tool ? null : tool;
          this.status = `選擇工具: ${tool}`;

          const projectData = {
            tool:tool
          };

          fetch('/api/tool1', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(projectData)
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                this.status = '專案儲存成功!';
              } else {
                this.status = '專案儲存失敗: ' + data.message;
              }
            })
            .catch(error => {
              this.status = '專案儲存失敗: ' + error.message;
              console.error('儲存專案時發生錯誤:', error);
            });
        },
        getMousePosition(event) {
          const rect = this.$refs.imageContainer.getBoundingClientRect();
          // Calculate the scroll position of the container
          const scrollLeft = this.$refs.imageContainer.scrollLeft;
          const scrollTop = this.$refs.imageContainer.scrollTop;
          // Calculate the click position relative to the image container
          // by accounting for the container's position, borders, and scroll position
          const x = event.clientX - rect.left + scrollLeft;
          const y = event.clientY - rect.top + scrollTop;
          return { x, y };
        },
        // 畫布點擊處理
        handleCanvasMouseDown(event) {
          // Get the bounding rectangle of the image container
          const { x, y } = this.getMousePosition(event);

          event.preventDefault();


          if (event.button === 0) { // 左鍵點擊
            // 記錄拖曳起始位置
            this.isDragging = true;
            this.dragStartX = x;
            this.dragStartY = y;
            this.status = `開始拖曳: x=${x}, y=${y}`;
            console.log(" drag start x: ", this.dragStartX, ", y: ", this.dragStartY);

          } else if (event.button === 2) { // 右鍵點擊
            this.status = `右鍵點擊: x=${x}, y=${y}`;
            // 處理右鍵點擊的功能，例如顯示上下文選單
            // 這裡添加您的右鍵點擊處理代碼

            // 示例：移除最近點
            if (this.points.length > 0) {
              this.points.pop();
              this.status = `右鍵移除最後一個點，剩餘 ${this.points.length} 個點`;
            }
          }
          this.updateImage('/png');
        },



        handleCanvasMouseMove(e) {
          
          if (!this.isDragging) return;

          const { x, y } = this.getMousePosition(e);
          this.sendDragToServer(x, y);
          // 拖曳過程中更新狀態
          this.status = `拖曳中: x=${x}, y=${y}`;

          // 您可以在這裡添加拖曳期間的視覺反饋
          // 例如畫一條線從起始點到當前位置
        },

        handleCanvasMouseUp(e) {
          const { x, y } = this.getMousePosition(e);
          if (e.button === 0) {
            console.log("mouse release");
            // 左鍵釋放
            if (this.isDragging) {
              this.isDragging = false;

              // 計算拖曳距離
              const dx = x - this.dragStartX;
              const dy = y - this.dragStartY;
              const distance = Math.sqrt(dx * dx + dy * dy);

              console.log("left relese ... x : ", x, " y : ", y, " distance : ", distance);
              if (distance < 5) {
                // 視為點擊而非拖曳
                this.handleLeftClick(x, y);
              } else {
                // 處理拖曳完成
                this.handleDragEnd(x, y);
              }
            }
          }
        },

        handleLeftClick(x, y) {
          console.log("left click ... ", x, " , ", y);
          this.status = `左鍵點擊: x=${x}, y=${y}`;
          this.points.push({ x, y });

          // 原有的功能：發送座標到伺服器
          this.sendPointToServer(x, y);
        },

        handleDragEnd(x, y) {
          this.status = `拖曳結束: 從 (${this.dragStartX}, ${this.dragStartY}) 到 (${x}, ${y})`;
          fetch('/api/dragDone', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              x,
              y,
              scw: this.$refs.imageContainer.scrollWidth,
              sch: this.$refs.imageContainer.scrollHeight
            })
          });
          // 在這裡加入拖曳結束後的處理邏輯
          // 例如：計算拖曳區域、選擇區域內的點等
        },

        sendPointToServer(x, y) {
          // 發送座標到伺服器
          fetch('/api/points', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              x,
              y,
              scw: this.$refs.imageContainer.scrollWidth,
              sch: this.$refs.imageContainer.scrollHeight
            })
          })
            .then(response => response.json())
            .then(data => {
              console.log('伺服器回應:', data);
              var x2 = data.x;
              var y2 = data.y;
              this.points.push({ x: x2, y: y2 });
              this.status = `最近的網格點: x=${x2}, y=${y2}`;
            })
            .catch(error => {
              this.status = 'point bad: ' + error.message;
            });
        },

        sendDragToServer(x, y) {
          // 發送座標到伺服器
          fetch('/api/drag', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              x,
              y,
              scw: this.$refs.imageContainer.scrollWidth,
              sch: this.$refs.imageContainer.scrollHeight
            })
          });
        },


        // 清除所有點
        clearPoints() {
          this.points = [];
          this.status = '已清除所有點';
        },

        // 新增圖層
        addLayer() {
          this.layerCounter++;
          const newLayer = {
            id: this.layerCounter,
            name: `圖層 ${this.layerCounter}`
          };
          this.layers.push(newLayer);
          this.status = `新增圖層: ${newLayer.name}`;
        },

        // 選擇圖層
        selectLayer(id) {
          this.selectedLayerId = id;
          const layer = this.layers.find(l => l.id === id);
          if (layer) {
            this.status = `選擇圖層: ${layer.name} , id = ${id}`;
          }
        },

        // 刪除選中圖層
        deleteLayer() {
          if (this.selectedLayerId) {
            const layerIndex = this.layers.findIndex(l => l.id === this.selectedLayerId);
            if (layerIndex !== -1) {
              const layerName = this.layers[layerIndex].name;
              this.layers.splice(layerIndex, 1);
              this.status = `刪除圖層: ${layerName}`;
              this.selectedLayerId = this.layers.length > 0 ? this.layers[0].id : null;
            }
          } else {
            this.status = '沒有選擇圖層';
          }
        },

        // 新增關鍵幀
        addKeyframe() {
          this.keyframeCounter++;
          this.keyframes.push({
            id: this.keyframeCounter,
            position: 50 * this.keyframeCounter
          });
          this.status = `新增關鍵幀: ${this.keyframeCounter}`;
        },

        // 選擇關鍵幀
        selectKeyframe(id) {
          this.status = `選擇關鍵幀: ${id}`;
        },

        // 新增時間軸元件
        addTimelineComponent() {
          this.status = '新增時間軸元件';
          alert('新增時間軸元件功能觸發');
        },

        // 時間軸拖曳功能
        startDrag(e) {
          this.isDragging = true;
          this.startX = e.pageX - this.$refs.timelineTracks.offsetLeft;
          this.scrollLeft = this.$refs.timelineTracks.scrollLeft;
        },

        onDrag(e) {
          if (!this.isDragging) return;
          e.preventDefault();
          const x = e.pageX - this.$refs.timelineTracks.offsetLeft;
          const walk = (x - this.startX);
          this.$refs.timelineTracks.scrollLeft = this.scrollLeft - walk;
        },

        stopDrag() {
          this.isDragging = false;
        },

        // 將專案儲存到伺服器的API示例
        saveProjectToServer() {
          this.status = '正在儲存專案...';

          const projectData = {
            layers: this.layers,
            keyframes: this.keyframes,
            points: this.points
          };

          fetch('/api/project/save', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(projectData)
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                this.status = '專案儲存成功!';
              } else {
                this.status = '專案儲存失敗: ' + data.message;
              }
            })
            .catch(error => {
              this.status = '專案儲存失敗: ' + error.message;
              console.error('儲存專案時發生錯誤:', error);
            });
        },

        // 將圖層儲存到伺服器的API示例
        saveLayerToServer() {
          if (!this.selectedLayerId) {
            this.status = '請先選擇一個圖層';
            return;
          }

          this.status = '正在儲存圖層...';

          const selectedLayer = this.layers.find(l => l.id === this.selectedLayerId);
          const layerData = {
            layerId: this.selectedLayerId,
            layerName: selectedLayer.name,
            points: this.points.filter(p => p.layerId === this.selectedLayerId || !p.layerId)
          };

          fetch('/api/layer/save', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(layerData)
          })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                this.status = `圖層 ${selectedLayer.name} 儲存成功!`;
              } else {
                this.status = '圖層儲存失敗: ' + data.message;
              }
            })
            .catch(error => {
              this.status = '圖層儲存失敗: ' + error.message;
              console.error('儲存圖層時發生錯誤:', error);
            });
        },

        // 點擊頁面其他區域關閉下拉選單
        handleClickOutside(e) {
          const targetElement = e.target;
          if (!targetElement.closest('.menu-item')) {
            this.closeAllDropdowns();
          }
        },
        toggleNode(nodeId) {
          if (this.expandedNodes.includes(nodeId)) {
            this.expandedNodes = this.expandedNodes.filter(id => id !== nodeId);
          } else {
            this.expandedNodes.push(nodeId);
          }
        },
        handleNameClick(name) {
          console.log('Clicked node name:', name);
        },

        // 遞迴渲染階層式結構的方法（可選的實作方式）
        renderHierarchicalData(node, parentId = '') {
          const nodeId = parentId ? `${parentId}-${node.name}` : node.name;
          const hasChildren = node.children && node.children.length > 0;

          return {
            id: nodeId,
            name: node.name,
            hasChildren: hasChildren,
            children: hasChildren ? node.children.map(child => this.renderHierarchicalData(child, nodeId)) : []
          };
        }
      }
    });

    // 掛載應用
    app.mount('#app');
  </script>
</body>

</html>
