<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html>
<head>
  <title>WebGL VBO, EBO, Texture, and Animation Demo</title>
  <style>
    canvas { border: 1px solid black; margin: 10px; }
    h3 { font-family: Arial; }
  </style>
</head>
<body>
  <h3>Separate Canvases</h3>
  <canvas id="canvas1" width="200" height="200"></canvas>
  <canvas id="canvas2" width="200" height="200"></canvas>
  <canvas id="canvas3" width="200" height="200"></canvas>
  <h3>Single Canvas</h3>
  <canvas id="canvas4" width="200" height="200"></canvas>
  <h3>Animated Canvas</h3>
  <canvas id="canvas5" width="200" height="200"></canvas>

  <script>
    // Vertex shader with texture coordinates and offset
    const vsSource = `
      attribute vec2 aPosition;
      attribute vec2 aTexCoord;
      uniform vec2 uOffset;
      varying vec2 vTexCoord;
      void main() {
        gl_Position = vec4(aPosition + uOffset, 0.0, 1.0);
        vTexCoord = aTexCoord;
      }
    `;

    // Fragment shader with texture
    const fsSource = `
      precision mediump float;
      varying vec2 vTexCoord;
      uniform sampler2D uTexture;
      void main() {
        gl_FragColor = texture2D(uTexture, vTexCoord);
      }
    `;

    // Initialize shader program
    function initShaderProgram(gl, vsSource, fsSource) {
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vsSource);
      gl.compileShader(vertexShader);

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fsSource);
      gl.compileShader(fragmentShader);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);

      return program;
    }

    // Initialize VBO
    function initVBO(gl, vertices) {
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      return vbo;
    }

    // Initialize EBO
    function initEBO(gl, indices) {
      const ebo = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      return ebo;
    }

    // Initialize texture
    function initTexture(gl, textureData) {
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, gl.UNSIGNED_BYTE, textureData);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      return texture;
    }

    // Draw VBO with EBO and texture
    function drawVBOwithEBO(gl, program, vbo, ebo, texture, indicesCount, offset = [0.0, 0.0]) {
      gl.useProgram(program);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ebo);

      const positionLoc = gl.getAttribLocation(program, 'aPosition');
      gl.enableVertexAttribArray(positionLoc);
      gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 4 * 4, 0);

      const texCoordLoc = gl.getAttribLocation(program, 'aTexCoord');
      gl.enableVertexAttribArray(texCoordLoc);
      gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 4 * 4, 2 * 4);

      const offsetLoc = gl.getUniformLocation(program, 'uOffset');
      gl.uniform2fv(offsetLoc, offset);

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      const textureLoc = gl.getUniformLocation(program, 'uTexture');
      gl.uniform1i(textureLoc, 0);

      gl.drawElements(gl.TRIANGLES, indicesCount, gl.UNSIGNED_SHORT, 0);
    }

    // Vertex data with texture coordinates (x, y, u, v)
    const vertices = [
      -0.2, -0.2, 0.0, 0.0,  // bottom-left
       0.0,  0.2, 0.5, 1.0,  // top
       0.2, -0.2, 1.0, 0.0,  // bottom-right
       0.0,  0.0, 0.5, 0.5   // center
    ];

    // Index data for three triangles
    const indices1 = [0, 1, 2]; // Texture 1 triangle
    const indices2 = [0, 1, 3]; // Texture 2 triangle
    const indices3 = [1, 2, 3]; // Texture 3 triangle

    // Texture data (2x2 pixels for simplicity)
    const textureData1 = new Uint8Array([ // Red checker
      255, 0, 0, 255,   0, 0, 0, 255,
      0, 0, 0, 255,   255, 0, 0, 255
    ]);
    const textureData2 = new Uint8Array([ // Green checker
      0, 255, 0, 255,   0, 0, 0, 255,
      0, 0, 0, 255,   0, 255, 0, 255
    ]);
    const textureData3 = new Uint8Array([ // Blue checker
      0, 0, 255, 255,   0, 0, 0, 255,
      0, 0, 0, 255,   0, 0, 255, 255
    ]);

    // Initialize separate canvases
    for (let i = 1; i <= 3; i++) {
      const canvas = document.getElementById(`canvas${i}`);
      const gl = canvas.getContext('webgl');
      const program = initShaderProgram(gl, vsSource, fsSource);
      const vbo = initVBO(gl, vertices);
      const indices = [indices1, indices2, indices3][i-1];
      const ebo = initEBO(gl, indices);
      const textureData = [textureData1, textureData2, textureData3][i-1];
      const texture = initTexture(gl, textureData);
      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      drawVBOwithEBO(gl, program, vbo, ebo, texture, 3);
    }

    // Initialize single canvas
    const canvas4 = document.getElementById('canvas4');
    const gl4 = canvas4.getContext('webgl');
    const program4 = initShaderProgram(gl4, vsSource, fsSource);
    const vbo4 = initVBO(gl4, vertices);
    const ebos = [
      initEBO(gl4, indices1),
      initEBO(gl4, indices2),
      initEBO(gl4, indices3)
    ];
    const textures = [
      initTexture(gl4, textureData1),
      initTexture(gl4, textureData2),
      initTexture(gl4, textureData3)
    ];
    gl4.clearColor(0.0, 0.0, 0.0, 1.0);
    gl4.clear(gl4.COLOR_BUFFER_BIT);
    for (let i = 0; i < 3; i++) {
      drawVBOwithEBO(gl4, program4, vbo4, ebos[i], textures[i], 3);
    }

    // Initialize animated canvas
    const canvas5 = document.getElementById('canvas5');
    const gl5 = canvas5.getContext('webgl');
    const program5 = initShaderProgram(gl5, vsSource, fsSource);
    const vbo5 = initVBO(gl5, vertices);
    const ebo5 = initEBO(gl5, indices1);
    const texture5 = initTexture(gl5, textureData1);

    function animate() {
      const time = performance.now() * 0.001;
      const offsetX = Math.sin(time) * 0.5;
      const offsetY = Math.cos(time) * 0.5;

      gl5.clearColor(0.0, 0.0, 0.0, 1.0);
      gl5.clear(gl5.COLOR_BUFFER_BIT);
      drawVBOwithEBO(gl5, program5, vbo5, ebo5, texture5, 3, [offsetX, offsetY]);

      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>