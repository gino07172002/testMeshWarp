<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Vue 3 + WebGL Texture Demo</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.3.4/vue.global.prod.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
    }
    
    #app {
      max-width: 800px;
      margin: 0 auto;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 400px;
      border: 1px solid #ccc;
      margin-bottom: 20px;
    }
    
    .controls {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
    }
    
    .toggle-button {
      padding: 8px 16px;
      background-color: #e0e0e0;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 5px;
    }
    
    .toggle-button.visible {
      background-color: #4CAF50;
      color: white;
    }
    
    .toggle-button.semi {
      background-color: #FFC107;
      color: white;
    }
    
    .info {
      margin-top: 20px;
      padding: 10px;
      background-color: #f0f0f0;
    }
  </style>
</head>
<body>
  <div id="app">
    <h2>Vue 3 + WebGL - Four Image Layers</h2>
    <canvas ref="canvas"></canvas>
    
    <div class="controls">
      <div v-for="(layer, index) in layers" :key="index" style="margin-bottom: 10px;">
        <span>Layer {{ index }}: </span>
        <button 
          class="toggle-button"
          :class="{ visible: layer.state === 'visible', semi: layer.state === 'semi' }"
          @click="toggleLayer(index, 'visible')"
        >
          顯示
        </button>
        <button 
          class="toggle-button"
          :class="{ semi: layer.state === 'semi' }"
          @click="toggleLayer(index, 'semi')"
        >
          半透明
        </button>
        <button 
          class="toggle-button"
          :class="{ visible: layer.state === 'hidden' }"
          @click="toggleLayer(index, 'hidden')"
        >
          隱藏
        </button>
      </div>
    </div>
    
    <div class="info">
      <p>This demo loads a single image (png3.png) from your local server and displays it as four separate textures in a 2x2 grid.</p>
      <p>By default, layers 0 and 2 are visible. You can toggle each layer's visibility using the buttons above.</p>
    </div>
  </div>
  
  <script>
    const { createApp, ref, onMounted, reactive } = Vue;
    
    createApp({
      setup() {
        const canvas = ref(null);
        const gl = ref(null);
        const program = ref(null);
        const texture = ref(null);
        const loaded = ref(false);
        
        const layers = reactive([
          { state: 'visible' },  // Layer 0 - visible by default
          { state: 'hidden' },   // Layer 1
          { state: 'visible' },  // Layer 2 - visible by default
          { state: 'hidden' }    // Layer 3
        ]);

        // Vertex shader program
        const vsSource = `
          attribute vec4 aVertexPosition;
          attribute vec2 aTextureCoord;
          varying highp vec2 vTextureCoord;
          void main(void) {
            gl_Position = aVertexPosition;
            vTextureCoord = aTextureCoord;
          }
        `;

        // Fragment shader program
        const fsSource = `
          precision mediump float;
          varying highp vec2 vTextureCoord;
          uniform sampler2D uSampler;
          uniform int uLayerState; // 0=hidden, 1=semi-transparent, 2=visible
          void main(void) {
            if(uLayerState > 0) {
              vec4 texColor = texture2D(uSampler, vTextureCoord);
              if(uLayerState == 1) { // semi-transparent
                texColor.a *= 0.5;
              }
              gl_FragColor = texColor;
            } else {
              gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
            }
          }
        `;

        // Initialize WebGL
        function initGL() {
          const canvasElement = canvas.value;
          gl.value = canvasElement.getContext('webgl');
          
          if (!gl.value) {
            alert('Unable to initialize WebGL. Your browser may not support it.');
            return;
          }
          
          // Set canvas size
          canvasElement.width = canvasElement.clientWidth;
          canvasElement.height = canvasElement.clientHeight;
          gl.value.viewport(0, 0, canvasElement.width, canvasElement.height);
          
          // Clear canvas
          gl.value.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.value.clear(gl.value.COLOR_BUFFER_BIT);
        }

        // Create shader program
        function initShaderProgram() {
          const loadShader = (type, source) => {
            const shader = gl.value.createShader(type);
            gl.value.shaderSource(shader, source);
            gl.value.compileShader(shader);

            if (!gl.value.getShaderParameter(shader, gl.value.COMPILE_STATUS)) {
              alert('An error occurred compiling the shaders: ' + gl.value.getShaderInfoLog(shader));
              gl.value.deleteShader(shader);
              return null;
            }

            return shader;
          };

          const vertexShader = loadShader(gl.value.VERTEX_SHADER, vsSource);
          const fragmentShader = loadShader(gl.value.FRAGMENT_SHADER, fsSource);

          // Create the shader program
          const shaderProgram = gl.value.createProgram();
          gl.value.attachShader(shaderProgram, vertexShader);
          gl.value.attachShader(shaderProgram, fragmentShader);
          gl.value.linkProgram(shaderProgram);

          // If creating the shader program failed, alert
          if (!gl.value.getProgramParameter(shaderProgram, gl.value.LINK_STATUS)) {
            alert('Unable to initialize the shader program: ' + gl.value.getProgramInfoLog(shaderProgram));
            return null;
          }

          program.value = shaderProgram;
        }

        // Load texture
        function loadTexture() {
          texture.value = gl.value.createTexture();
          gl.value.bindTexture(gl.value.TEXTURE_2D, texture.value);

          // Fill the texture with a 1x1 blue pixel until the image loads
          gl.value.texImage2D(
            gl.value.TEXTURE_2D, 0, gl.value.RGBA, 1, 1, 0, gl.value.RGBA,
            gl.value.UNSIGNED_BYTE, new Uint8Array([0, 0, 255, 255])
          );

          // Load the image
          const image = new Image();
          image.onload = () => {
            gl.value.bindTexture(gl.value.TEXTURE_2D, texture.value);
            gl.value.texImage2D(
              gl.value.TEXTURE_2D, 0, gl.value.RGBA, gl.value.RGBA,
              gl.value.UNSIGNED_BYTE, image
            );

            // Use mipmaps if the image is a power of 2 in both dimensions
            if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
              gl.value.generateMipmap(gl.value.TEXTURE_2D);
            } else {
              gl.value.texParameteri(gl.value.TEXTURE_2D, gl.value.TEXTURE_WRAP_S, gl.value.CLAMP_TO_EDGE);
              gl.value.texParameteri(gl.value.TEXTURE_2D, gl.value.TEXTURE_WRAP_T, gl.value.CLAMP_TO_EDGE);
              gl.value.texParameteri(gl.value.TEXTURE_2D, gl.value.TEXTURE_MIN_FILTER, gl.value.LINEAR);
            }
            
            loaded.value = true;
            draw();
          };
          
          image.onerror = () => {
            alert('Failed to load image: ./png3.png');
          };
          
          // Set the source to local server path
          image.src = './png3.png';
        }

        function isPowerOf2(value) {
          return (value & (value - 1)) === 0;
        }

        // Draw the scene
        function draw() {
          if (!loaded.value) return;

          const canvasElement = canvas.value;
          gl.value.clearColor(0.0, 0.0, 0.0, 1.0);
          gl.value.clear(gl.value.COLOR_BUFFER_BIT);
          
          gl.value.useProgram(program.value);
          
          // Get attribute and uniform locations
          const vertexPositionAttribute = gl.value.getAttribLocation(program.value, 'aVertexPosition');
          const textureCoordAttribute = gl.value.getAttribLocation(program.value, 'aTextureCoord');
          const samplerUniform = gl.value.getUniformLocation(program.value, 'uSampler');
          const layerStateUniform = gl.value.getUniformLocation(program.value, 'uLayerState');

          gl.value.enableVertexAttribArray(vertexPositionAttribute);
          gl.value.enableVertexAttribArray(textureCoordAttribute);

          // Set the active texture
          gl.value.activeTexture(gl.value.TEXTURE0);
          gl.value.bindTexture(gl.value.TEXTURE_2D, texture.value);
          gl.value.uniform1i(samplerUniform, 0);

          // Set up buffers for each quadrant
          drawQuadrant(0, vertexPositionAttribute, textureCoordAttribute, layerStateUniform);
          drawQuadrant(1, vertexPositionAttribute, textureCoordAttribute, layerStateUniform);
          drawQuadrant(2, vertexPositionAttribute, textureCoordAttribute, layerStateUniform);
          drawQuadrant(3, vertexPositionAttribute, textureCoordAttribute, layerStateUniform);
        }

        // Draw a specific quadrant (0 = top-left, 1 = top-right, 2 = bottom-left, 3 = bottom-right)
        function drawQuadrant(quadrant, vertexPositionAttribute, textureCoordAttribute, layerStateUniform) {
          // Determine the quadrant vertices
          let positions;
          switch (quadrant) {
            case 0: // Top-left
              positions = [
                -1.0, 1.0,  // top-left
                0.0, 1.0,   // top-right
                -1.0, 0.0,  // bottom-left
                0.0, 0.0,   // bottom-right
              ];
              break;
            case 1: // Top-right
              positions = [
                0.0, 1.0,   // top-left
                1.0, 1.0,   // top-right
                0.0, 0.0,   // bottom-left
                1.0, 0.0,   // bottom-right
              ];
              break;
            case 2: // Bottom-left
              positions = [
                -1.0, 0.0,  // top-left
                0.0, 0.0,   // top-right
                -1.0, -1.0, // bottom-left
                0.0, -1.0,  // bottom-right
              ];
              break;
            case 3: // Bottom-right
              positions = [
                0.0, 0.0,   // top-left
                1.0, 0.0,   // top-right
                0.0, -1.0,  // bottom-left
                1.0, -1.0,  // bottom-right
              ];
              break;
          }

          // Create and bind buffer for positions
          const positionBuffer = gl.value.createBuffer();
          gl.value.bindBuffer(gl.value.ARRAY_BUFFER, positionBuffer);
          gl.value.bufferData(gl.value.ARRAY_BUFFER, new Float32Array(positions), gl.value.STATIC_DRAW);
          gl.value.vertexAttribPointer(vertexPositionAttribute, 2, gl.value.FLOAT, false, 0, 0);

          // Create and bind buffer for texture coordinates
          const textureCoordinates = [
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            1.0, 1.0,
          ];
          const textureCoordBuffer = gl.value.createBuffer();
          gl.value.bindBuffer(gl.value.ARRAY_BUFFER, textureCoordBuffer);
          gl.value.bufferData(gl.value.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.value.STATIC_DRAW);
          gl.value.vertexAttribPointer(textureCoordAttribute, 2, gl.value.FLOAT, false, 0, 0);

          // Set the visibility of this layer
          let layerStateValue = 0; // hidden by default
          if (layers[quadrant].state === 'visible') {
            layerStateValue = 2; // fully visible
          } else if (layers[quadrant].state === 'semi') {
            layerStateValue = 1; // semi-transparent
          }
          gl.value.uniform1i(layerStateUniform, layerStateValue);

          // Draw the quadrant
          gl.value.drawArrays(gl.value.TRIANGLE_STRIP, 0, 4);
        }

        // Toggle layer visibility
        function toggleLayer(index, newState) {
          layers[index].state = newState;
          draw();
        }
        
        // Initialize everything
        onMounted(() => {
          initGL();
          if (gl.value) {
            initShaderProgram();
            loadTexture();
          }
          
          // Handle window resize
          window.addEventListener('resize', () => {
            if (gl.value) {
              canvas.value.width = canvas.value.clientWidth;
              canvas.value.height = canvas.value.clientHeight;
              gl.value.viewport(0, 0, canvas.value.width, canvas.value.height);
              draw();
            }
          });
        });

        return {
          canvas,
          layers,
          toggleLayer
        };
      }
    }).mount('#app');
  </script>
</body>
</html>