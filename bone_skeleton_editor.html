<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script>```html
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>骨骼與骨架編輯器</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
            gap: 20px;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .panel {
            width: 300px;
            background: #333;
            border-radius: 8px;
            padding: 20px;
            overflow-y: auto;
        }
        
        .controls {
            margin-bottom: 30px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 14px;
            text-transform: uppercase;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #45a049;
        }
        
        .btn.active {
            background: #FF9800;
        }
        
        .btn.danger {
            background: #f44336;
        }
        
        .btn.danger:hover {
            background: #d32f2f;
        }
        
        .info {
            background: #444;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 12px;
        }
        
        .bone-list {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .bone-item {
            background: #555;
            margin-bottom: 5px;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .bone-item:hover {
            background: #666;
        }
        
        .bone-item.selected {
            background: #4CAF50;
        }
        
        .instructions {
            background: #2a2a2a;
            border: 1px solid #4CAF50;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .status {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        .checkbox-group, .input-group {
            display: flex;
            align-items: center;
            font-size: 12px;
            margin-top: 10px;
        }
        
        .checkbox-group input, .input-group input {
            margin-right: 8px;
        }
        
        .input-group input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #555;
            background: #444;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="status" id="status">準備就緒</div>
        </div>
        
        <div class="panel">
            <div class="instructions">
                <h3>操作說明</h3>
                <p><strong>創建骨骼:</strong> 左鍵點擊設定頭部，拖曳決定尾部</p>
                <p><strong>選擇/編輯骨骼:</strong> 右鍵點擊骨骼線條或端點</p>
                <p><strong>移動骨骼:</strong> 右鍵拖拽骨骼的頭部或尾部</p>
                <p><strong>創建子骨骼:</strong> 選中父骨骼後，左鍵點擊任意位置設定頭部，拖曳決定尾部</p>
                <p><strong>取消選擇:</strong> 右鍵點擊畫布空白處</p>
                <p><strong>近距離選擇:</strong> 勾選後，滑鼠靠近骨骼端點時自動切換到選擇/編輯</p>
                <p><strong>滑鼠靠近:</strong> 滑鼠靠近骨骼端點時會變為黃色</p>
                <p><strong>選擇距離:</strong> 調整滑鼠檢測骨骼端點的距離範圍</p>
            </div>
            
            <div class="controls">
                <div class="control-group">
                    <h3>工具</h3>
                    <button class="btn active" id="createTool">創建骨骼</button>
                    <button class="btn" id="selectTool">選擇/編輯</button>
                    <button class="btn danger" id="deleteTool">刪除</button>
                </div>
                
                <div class="control-group">
                    <h3>操作</h3>
                    <button class="btn" id="clearAll">清空全部</button>
                    <button class="btn" id="exportJson">匯出JSON</button>
                </div>
                
                <div class="control-group">
                    <h3>選項</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="proximitySelect" checked>
                        <label for="proximitySelect">啟用近距離選擇/編輯</label>
                    </div>
                    <div class="input-group">
                        <input type="number" id="selectionDistance" value="8" min="1" max="50">
                        <label for="selectionDistance">選擇距離 (像素)</label>
                    </div>
                </div>
            </div>
            
            <div class="info">
                <h3>骨架資訊</h3>
                <div>骨骼數量: <span id="boneCount">0</span></div>
                <div>根骨骼: <span id="rootCount">0</span></div>
                <div>選中骨骼: <span id="selectedBone">無</span></div>
            </div>
            
            <div class="control-group">
                <h3>骨骼列表</h3>
                <div class="bone-list" id="boneList"></div>
            </div>
        </div>
    </div>

    <script id="vertex-shader-2d" type="notjs">
        attribute vec2 a_position;
        uniform vec2 u_resolution;
        void main() {
            vec2 zeroToOne = a_position / u_resolution;
            vec2 zeroToTwo = zeroToOne * 2.0;
            vec2 clipSpace = zeroToTwo - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
        }
    </script>
    <script id="fragment-shader-2d" type="notjs">
        precision mediump float;
        uniform vec4 u_color;
        void main() {
            gl_FragColor = u_color;
        }
    </script>

    <script type="module">
        class Vertex {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.groups = {};
            }
            
            setWeight(groupName, weight) {
                if (weight <= 0) {
                    this.removeWeight(groupName);
                    return;
                }
                this.groups[groupName] = Math.max(0, Math.min(1, weight));
            }
            
            removeWeight(groupName) {
                delete this.groups[groupName];
            }
            
            getWeight(groupName) {
                return this.groups[groupName] || 0;
            }
        }

        class Bone {
            constructor(name, headX, headY, length = 50, rotation = 0, parent = null, blenderMode = true) {
                if (!name || typeof name !== 'string') {
                    throw new Error('Bone name must be a non-empty string');
                }

                this.name = name;
                this.localHead = { x: headX, y: headY };
                this.length = Math.max(0, length);
                this.rotation = rotation;
                this.parent = parent;
                this.children = [];
                this.blenderMode = blenderMode;

                this._globalTransformCache = null;
                this._isDirty = true;

                if (parent) {
                    parent.children.push(this);
                    parent._markDirty();
                }
            }

            _markDirty() {
                this._isDirty = true;
                this._globalTransformCache = null;
                this.children.forEach(child => child._markDirty());
            }

            _localToGlobal(localX, localY, parentTransform) {
                if (!parentTransform) return { x: localX, y: localY };
                
                const cos = Math.cos(parentTransform.rotation);
                const sin = Math.sin(parentTransform.rotation);
                const basePoint = this.blenderMode ? parentTransform.tail : parentTransform.head;
                
                return {
                    x: basePoint.x + localX * cos - localY * sin,
                    y: basePoint.y + localX * sin + localY * cos
                };
            }

            setLength(newLength) {
                this.length = Math.max(0, newLength);
                this._markDirty();
            }

            setRotation(newRotation) {
                this.rotation = newRotation;
                this._markDirty();
            }

            setLocalHead(x, y) {
                this.localHead.x = x;
                this.localHead.y = y;
                this._markDirty();
            }

            setGlobalHead(x, y) {
                if (!this.parent) {
                    this.localHead.x = x;
                    this.localHead.y = y;
                } else {
                    const parentTransform = this.parent.getGlobalTransform();
                    const local = this._globalToLocal(x, y, parentTransform);
                    this.localHead.x = local.x;
                    this.localHead.y = local.y;
                }
                this._markDirty();
            }

            setGlobalTail(x, y) {
                const globalHead = this.getGlobalTransform().head;
                const dx = x - globalHead.x;
                const dy = y - globalHead.y;
                this.length = Math.sqrt(dx * dx + dy * dy);
                const parentRotation = this.parent ? this.parent.getGlobalTransform().rotation : 0;
                this.rotation = Math.atan2(dy, dx) - parentRotation;
                this._markDirty();
            }

            _globalToLocal(globalX, globalY, parentTransform) {
                if (!parentTransform) return { x: globalX, y: globalY };
                
                const basePoint = this.blenderMode ? parentTransform.tail : parentTransform.head;
                const dx = globalX - basePoint.x;
                const dy = globalY - basePoint.y;
                const cos = Math.cos(-parentTransform.rotation);
                const sin = Math.sin(-parentTransform.rotation);
                
                return {
                    x: dx * cos - dy * sin,
                    y: dx * sin + dy * cos
                };
            }

            getGlobalTransform() {
                if (!this._isDirty && this._globalTransformCache) {
                    return this._globalTransformCache;
                }

                this._globalTransformCache = this._calculateGlobalTransform();
                this._isDirty = false;
                return this._globalTransformCache;
            }

            _calculateGlobalTransform() {
                if (!this.parent) {
                    const head = { x: this.localHead.x, y: this.localHead.y };
                    const tail = {
                        x: head.x + this.length * Math.cos(this.rotation),
                        y: head.y + this.length * Math.sin(this.rotation)
                    };
                    return { head, tail, rotation: this.rotation };
                }

                const parentTransform = this.parent.getGlobalTransform();
                const globalHead = this._localToGlobal(this.localHead.x, this.localHead.y, parentTransform);
                
                const totalRotation = parentTransform.rotation + this.rotation;
                const tail = {
                    x: globalHead.x + this.length * Math.cos(totalRotation),
                    y: globalHead.y + this.length * Math.sin(totalRotation)
                };

                return {
                    head: globalHead,
                    tail: tail,
                    rotation: totalRotation
                };
            }

            setParent(newParent) {
                if (this.parent) {
                    const index = this.parent.children.indexOf(this);
                    if (index >= 0) {
                        this.parent.children.splice(index, 1);
                    }
                }

                this.parent = newParent;
                if (newParent) {
                    newParent.children.push(this);
                }
                
                this._markDirty();
            }
        }

        class Skeleton {
            constructor(name = "") {
                this.name = name;
                this.bones = [];
                this.boneMap = new Map();
                this.rootBones = [];
            }

            addBone(name, x, y, length = 50, rotation = 0, parent = null, blenderMode = true) {
                if (this.boneMap.has(name)) {
                    throw new Error(`Bone with name "${name}" already exists`);
                }

                const bone = new Bone(name, x, y, length, rotation, parent, blenderMode);
                this.bones.push(bone);
                this.boneMap.set(name, bone);
                
                if (!parent) {
                    this.rootBones.push(bone);
                }
                
                return bone;
            }

            getBone(name) {
                return this.boneMap.get(name);
            }

            removeBone(name) {
                const bone = this.getBone(name);
                if (!bone) return false;
                
                if (bone.parent) {
                    const index = bone.parent.children.indexOf(bone);
                    if (index >= 0) bone.parent.children.splice(index, 1);
                } else {
                    const index = this.rootBones.indexOf(bone);
                    if (index >= 0) this.rootBones.splice(index, 1);
                }
                
                bone.children.forEach(child => {
                    child.setParent(bone.parent);
                });
                
                const boneIndex = this.bones.indexOf(bone);
                if (boneIndex >= 0) this.bones.splice(boneIndex, 1);
                this.boneMap.delete(name);
                
                return true;
            }

            forEachBone(callback) {
                this.bones.forEach(callback);
            }

            clear() {
                this.bones = [];
                this.boneMap.clear();
                this.rootBones = [];
            }
        }

        class Project2D {
            constructor(name = "Untitled Project") {
                this.name = name;
                this.skeletons = [];
                this.skeletonMap = new Map();
            }

            addSkeleton(name) {
                if (this.skeletonMap.has(name)) {
                    throw new Error(`Skeleton with name "${name}" already exists`);
                }
                
                const skeleton = new Skeleton(name);
                this.skeletons.push(skeleton);
                this.skeletonMap.set(name, skeleton);
                return skeleton;
            }

            getSkeleton(name) {
                return this.skeletonMap.get(name);
            }
        }

        class BoneEditor {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.gl = this.canvas.getContext('webgl');
                if (!this.gl) {
                    console.error('WebGL not supported');
                    return;
                }
                this.project = new Project2D('骨骼編輯器項目');
                this.skeleton = this.project.addSkeleton('主骨架');
                
                this.currentTool = 'create';
                this.selectedBone = null;
                this.dragTarget = null;
                this.isDragging = false;
                this.createStep = 0;
                this.tempHead = null;
                this.tempTail = null;
                this.boneCounter = 1;
                this.mouseX = 0;
                this.mouseY = 0;
                this.proximitySelectEnabled = true;
                this.selectionDistance = 8;
                
                this.setupWebGL();
                this.setupEventListeners();
                this.setupUI();
                this.render();
            }

            setupWebGL() {
                this.vertexShaderSource = document.querySelector("#vertex-shader-2d").text;
                this.fragmentShaderSource = document.querySelector("#fragment-shader-2d").text;

                this.vertexShader = this.createShader(this.gl.VERTEX_SHADER, this.vertexShaderSource);
                this.fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, this.fragmentShaderSource);

                this.program = this.createProgram(this.vertexShader, this.fragmentShader);

                this.positionAttributeLocation = this.gl.getAttribLocation(this.program, "a_position");
                this.resolutionUniformLocation = this.gl.getUniformLocation(this.program, "u_resolution");
                this.colorUniformLocation = this.gl.getUniformLocation(this.program, "u_color");

                this.positionBuffer = this.gl.createBuffer();

                this.gl.clearColor(0.164, 0.164, 0.164, 1.0); // #2a2a2a
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                return program;
            }

            resizeCanvas() {
                const rect = this.canvas.parentElement.getBoundingClientRect();
                if (this.canvas.width !== rect.width || this.canvas.height !== rect.height) {
                    this.canvas.width = rect.width;
                    this.canvas.height = rect.height;
                    this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                    this.render();
                }
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        this.handleMouseDown(e);
                    } else if (e.button === 2) { // Right click
                        this.handleRightClick(e);
                    }
                });
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0 || e.button === 2) {
                        this.handleMouseUp(e);
                    }
                });
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault(); // Prevent default context menu
                });
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            setupUI() {
                document.getElementById('createTool').addEventListener('click', () => this.setTool('create'));
                document.getElementById('selectTool').addEventListener('click', () => this.setTool('select'));
                document.getElementById('deleteTool').addEventListener('click', () => this.setTool('delete'));
                document.getElementById('clearAll').addEventListener('click', () => this.clearAll());
                document.getElementById('exportJson').addEventListener('click', () => this.exportToJson());
                document.getElementById('proximitySelect').addEventListener('change', (e) => {
                    this.proximitySelectEnabled = e.target.checked;
                });
                document.getElementById('selectionDistance').addEventListener('input', (e) => {
                    this.selectionDistance = Math.max(1, Math.min(50, parseFloat(e.target.value) || 8));
                    this.render();
                });
            }

            setTool(tool) {
                this.currentTool = tool;
                this.cancelCurrentOperation();
                
                document.querySelectorAll('.btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById(tool + 'Tool').classList.add('active');
                
                switch(tool) {
                    case 'create':
                        this.canvas.style.cursor = 'crosshair';
                        break;
                    case 'select':
                        this.canvas.style.cursor = 'pointer';
                        break;
                    case 'delete':
                        this.canvas.style.cursor = 'not-allowed';
                        break;
                }
            }

            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            handleMouseDown(e) {
                const mousePos = this.getMousePos(e);
                
                switch(this.currentTool) {
                    case 'create':
                        this.handleCreateMouseDown(mousePos);
                        break;
                    case 'delete':
                        this.handleDeleteMouseDown(mousePos);
                        break;
                }
            }

            handleRightClick(e) {
                const mousePos = this.getMousePos(e);
                
                if (this.currentTool === 'select' || this.currentTool === 'create') {
                    this.handleSelectMouseDown(mousePos);
                } else if (this.currentTool === 'delete') {
                    this.handleDeleteMouseDown(mousePos);
                } else {
                    // Deselect if clicking on empty space
                    const bone = this.getBoneAtPosition(mousePos);
                    const endpoint = this.getEndpointAtPosition(mousePos);
                    if (!bone && !endpoint) {
                        this.selectedBone = null;
                        this.cancelCurrentOperation();
                        this.updateBoneList();
                        this.render();
                    }
                }
            }

            handleMouseMove(e) {
                const mousePos = this.getMousePos(e);
                this.mouseX = mousePos.x;
                this.mouseY = mousePos.y;
                
                if (this.isDragging && this.dragTarget) {
                    this.handleDrag(mousePos);
                } else if (this.currentTool === 'create' && this.createStep === 1) {
                    this.tempTail = mousePos;
                }
                
                this.updateStatus(mousePos);
                this.render();
            }

            handleMouseUp(e) {
                const mousePos = this.getMousePos(e);
                if (this.isDragging && this.dragTarget) {
                    this.isDragging = false;
                    this.dragTarget = null;
                    this.updateBoneList();
                    this.render();
                } else if (this.currentTool === 'create' && this.createStep === 1 && e.button === 0) {
                    this.createBoneFromDrag(this.tempHead, mousePos);
                    this.createStep = 0;
                    this.tempHead = null;
                    this.tempTail = null;
                    this.render();
                }
            }

            handleCreateMouseDown(mousePos) {
                if (this.proximitySelectEnabled && !this.selectedBone && this.currentTool === 'create') {
                    const endpoint = this.getEndpointAtPosition(mousePos);
                    if (endpoint) {
                        return; // Prevent creating when clicking near an endpoint
                    }
                }

                if (this.createStep === 0) {
                    this.tempHead = mousePos;
                    this.tempTail = mousePos;
                    this.createStep = 1;
                    this.updateStatus(mousePos, '拖曳決定尾部位置');
                }
            }

            createBoneFromDrag(headPos, tailPos) {
                const dx = tailPos.x - headPos.x;
                const dy = tailPos.y - headPos.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                let rotation = Math.atan2(dy, dx);
                
                const boneName = `bone_${this.boneCounter++}`;
                
                try {
                    let parent = this.selectedBone;
                    let headX = headPos.x;
                    let headY = headPos.y;
                    
                    if (parent) {
                        const parentTransform = parent.getGlobalTransform();
                        const localHead = this._globalToLocal(headPos.x, headPos.y, parentTransform, parent.blenderMode);
                        headX = localHead.x;
                        headY = localHead.y;
                        rotation -= parentTransform.rotation;
                    }
                    
                    const bone = this.skeleton.addBone(boneName, headX, headY, length, rotation, parent);
                    this.selectedBone = bone;
                    this.updateBoneList();
                    
                    this.updateStatus(tailPos, `創建了骨骼: ${boneName}`);
                } catch (error) {
                    this.updateStatus(tailPos, `錯誤: ${error.message}`);
                }
            }

            handleSelectMouseDown(mousePos) {
                const endpoint = this.getEndpointAtPosition(mousePos);
                if (endpoint) {
                    this.dragTarget = endpoint;
                    this.isDragging = true;
                    this.selectedBone = endpoint.bone;
                    this.updateBoneList();
                    this.render();
                    return;
                }
                
                const bone = this.getBoneAtPosition(mousePos);
                if (bone) {
                    this.selectedBone = bone;
                    this.updateBoneList();
                    this.render();
                }
            }

            handleDeleteMouseDown(mousePos) {
                const bone = this.getBoneAtPosition(mousePos);
                if (bone) {
                    this.skeleton.removeBone(bone.name);
                    this.selectedBone = null;
                    this.updateBoneList();
                    this.render();
                }
            }

            handleDrag(mousePos) {
                if (!this.dragTarget) return;
                
                const { bone, point } = this.dragTarget;
                
                if (point === 'head') {
                    bone.setGlobalHead(mousePos.x, mousePos.y);
                } else if (point === 'tail') {
                    bone.setGlobalTail(mousePos.x, mousePos.y);
                }
                
                this.render();
            }

            _globalToLocal(globalX, globalY, parentTransform, blenderMode) {
                const basePoint = blenderMode ? parentTransform.tail : parentTransform.head;
                const dx = globalX - basePoint.x;
                const dy = globalY - basePoint.y;
                const cos = Math.cos(-parentTransform.rotation);
                const sin = Math.sin(-parentTransform.rotation);
                
                return {
                    x: dx * cos - dy * sin,
                    y: dx * sin + dy * cos
                };
            }

            getBoneAtPosition(pos) {
                const tolerance = 5;
                
                for (const bone of this.skeleton.bones) {
                    const transform = bone.getGlobalTransform();
                    const head = transform.head;
                    const tail = transform.tail;
                    
                    const dist = this.pointToLineDistance(pos, head, tail);
                    if (dist <= tolerance) {
                        return bone;
                    }
                }
                
                return null;
            }

            getEndpointAtPosition(pos) {
                const tolerance = this.selectionDistance;
                
                for (const bone of this.skeleton.bones) {
                    const transform = bone.getGlobalTransform();
                    const head = transform.head;
                    const tail = transform.tail;
                    
                    if (Math.sqrt((pos.x - head.x) ** 2 + (pos.y - head.y) ** 2) <= tolerance) {
                        return { bone, point: 'head' };
                    }
                    
                    if (Math.sqrt((pos.x - tail.x) ** 2 + (pos.y - tail.y) ** 2) <= tolerance) {
                        return { bone, point: 'tail' };
                    }
                }
                
                return null;
            }

            pointToLineDistance(point, lineStart, lineEnd) {
                const A = point.x - lineStart.x;
                const B = point.y - lineStart.y;
                const C = lineEnd.x - lineStart.x;
                const D = lineEnd.y - lineStart.y;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) return Math.sqrt(A * A + B * B);
                
                let param = dot / lenSq;
                
                if (param < 0) {
                    return Math.sqrt(A * A + B * B);
                } else if (param > 1) {
                    const dx = point.x - lineEnd.x;
                    const dy = point.y - lineEnd.y;
                    return Math.sqrt(dx * dx + dy * dy);
                } else {
                    const projX = lineStart.x + param * C;
                    const projY = lineStart.y + param * D;
                    const dx = point.x - projX;
                    const dy = point.y - projY;
                    return Math.sqrt(dx * dx + dy * dy);
                }
            }

            cancelCurrentOperation() {
                this.createStep = 0;
                this.tempHead = null;
                this.tempTail = null;
                this.isDragging = false;
                this.dragTarget = null;
                this.render();
            }

            clearAll() {
                this.skeleton.clear();
                this.selectedBone = null;
                this.cancelCurrentOperation();
                this.boneCounter = 1;
                this.updateBoneList();
                this.render();
            }

            updateStatus(mousePos, customMessage = null) {
                let message = customMessage || '';
                
                if (!customMessage) {
                    if (this.currentTool === 'create') {
                        if (this.selectedBone) {
                            message = '左鍵點擊設定子骨骼頭部，拖曳決定尾部';
                        } else if (this.createStep === 0) {
                            message = '左鍵點擊設定頭部，拖曳決定尾部';
                        } else {
                            message = '拖曳決定尾部位置';
                        }
                    } else if (this.currentTool === 'select') {
                        message = '右鍵點擊選擇或編輯骨骼';
                    } else if (this.currentTool === 'delete') {
                        message = '右鍵點擊刪除骨骼';
                    } else {
                        message = `滑鼠位置: (${Math.round(mousePos.x)}, ${Math.round(mousePos.y)})`;
                    }
                }
                
                document.getElementById('status').textContent = message;
            }

            updateBoneList() {
                const boneList = document.getElementById('boneList');
                const boneCount = document.getElementById('boneCount');
                const rootCount = document.getElementById('rootCount');
                const selectedBone = document.getElementById('selectedBone');
                
                boneList.innerHTML = '';
                boneCount.textContent = this.skeleton.bones.length;
                rootCount.textContent = this.skeleton.rootBones.length;
                selectedBone.textContent = this.selectedBone ? this.selectedBone.name : '無';
                
                this.skeleton.bones.forEach(bone => {
                    const item = document.createElement('div');
                    item.className = 'bone-item';
                    if (bone === this.selectedBone) {
                        item.classList.add('selected');
                    }
                    
                    const parentName = bone.parent ? bone.parent.name : '根骨骼';
                    const length = Math.round(bone.length);
                    const rotation = Math.round(bone.rotation * 180 / Math.PI);
                    
                    item.innerHTML = `
                        <div><strong>${bone.name}</strong></div>
                        <div>父骨骼: ${parentName}</div>
                        <div>長度: ${length}px, 角度: ${rotation}°</div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.selectedBone = bone;
                        this.updateBoneList();
                        this.render();
                    });
                    
                    boneList.appendChild(item);
                });
            }

            exportToJson() {
                const data = {
                    skeleton: {
                        name: this.skeleton.name,
                        bones: this.skeleton.bones.map(bone => ({
                            name: bone.name,
                            localHead: bone.localHead,
                            length: bone.length,
                            rotation: bone.rotation,
                            parentName: bone.parent ? bone.parent.name : null,
                            blenderMode: bone.blenderMode
                        }))
                    }
                };
                
                const json = JSON.stringify(data, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'skeleton.json';
                a.click();
                URL.revokeObjectURL(url);
            }

            render() {
                const gl = this.gl;
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                gl.useProgram(this.program);
                gl.uniform2f(this.resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
                
                this.drawGridWebGL();

                const mousePos = { x: this.mouseX, y: this.mouseY };
                const endpoint = this.getEndpointAtPosition(mousePos);
                const highlightedBone = endpoint ? endpoint.bone : null;

                this.skeleton.bones.forEach(bone => {
                    this.drawBoneWebGL(bone, bone === highlightedBone);
                });
                
                if (this.currentTool === 'create' && this.createStep === 1 && this.tempHead) {
                    this.drawTempBoneWebGL(this.tempHead, this.tempTail || this.tempHead);
                }
            }

            drawGridWebGL() {
                const gl = this.gl;
                const gridSize = 20;
                const color = [0.2, 0.2, 0.2, 1.0]; // #333
                gl.uniform4fv(this.colorUniformLocation, color);

                let positions = [];

                for (let x = 0; x <= this.canvas.width; x += gridSize) {
                    positions.push(x, 0, x, this.canvas.height);
                }

                for (let y = 0; y <= this.canvas.height; y += gridSize) {
                    positions.push(0, y, this.canvas.width, y);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

                gl.drawArrays(gl.LINES, 0, positions.length / 2);
            }

            drawBoneWebGL(bone, isHighlighted = false) {
                const gl = this.gl;
                const transform = bone.getGlobalTransform();
                const head = transform.head;
                const tail = transform.tail;
                
                const isSelected = bone === this.selectedBone;
                
                let lineColor = isHighlighted ? [1.0, 1.0, 0.0, 1.0] : (isSelected ? [1.0, 0.596, 0.0, 1.0] : [0.298, 0.686, 0.314, 1.0]); // Yellow, Orange, Green
                gl.uniform4fv(this.colorUniformLocation, lineColor);
                
                let positions = [head.x, head.y, tail.x, tail.y];
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINES, 0, 2);

                let headColor = isHighlighted ? [1.0, 1.0, 0.0, 1.0] : (isSelected ? [1.0, 0.596, 0.0, 1.0] : [0.129, 0.588, 0.953, 1.0]); // Yellow, Orange, Blue
                this.drawCircleWebGL(head.x, head.y, 5, headColor);

                const angle = Math.atan2(tail.y - head.y, tail.x - head.x);
                const size = 8;
                let tailColor = isHighlighted ? [1.0, 1.0, 0.0, 1.0] : (isSelected ? [1.0, 0.596, 0.0, 1.0] : [0.298, 0.686, 0.314, 1.0]); // Yellow, Orange, Green
                const p1 = {x: tail.x + Math.cos(angle) * size, y: tail.y + Math.sin(angle) * size};
                const p2 = {x: tail.x + Math.cos(angle + 2.5) * size, y: tail.y + Math.sin(angle + 2.5) * size};
                const p3 = {x: tail.x + Math.cos(angle - 2.5) * size, y: tail.y + Math.sin(angle - 2.5) * size};
                this.drawTriangleWebGL(p1, p2, p3, tailColor);
            }

            drawCircleWebGL(cx, cy, r, color) {
                const gl = this.gl;
                gl.uniform4fv(this.colorUniformLocation, color);

                const segments = 32;
                let positions = [];
                for (let i = 0; i <= segments; i++) {
                    const theta = i / segments * Math.PI * 2;
                    positions.push(cx + Math.cos(theta) * r, cy + Math.sin(theta) * r);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLE_FAN, 0, positions.length / 2);
            }

            drawTriangleWebGL(p1, p2, p3, color) {
                const gl = this.gl;
                gl.uniform4fv(this.colorUniformLocation, color);

                const positions = [p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];

                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
            }

            drawTempBoneWebGL(head, tail) {
                const gl = this.gl;
                gl.uniform4fv(this.colorUniformLocation, [1.0, 0.757, 0.027, 1.0]); // #FFC107
                let positions = [head.x, head.y, tail.x, tail.y];
                gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(this.positionAttributeLocation);
                gl.vertexAttribPointer(this.positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                gl.drawArrays(gl.LINES, 0, 2);

                this.drawCircleWebGL(head.x, head.y, 4, [1.0, 0.757, 0.027, 1.0]);
            }
        }

        const editor = new BoneEditor('canvas');
        
        editor.canvas.addEventListener('mousemove', (e) => {
            const rect = editor.canvas.getBoundingClientRect();
            editor.mouseX = e.clientX - rect.left;
            editor.mouseY = e.clientY - rect.top;
        });

        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case '1':
                    editor.setTool('create');
                    break;
                case '2':
                    editor.setTool('select');
                    break;
                case '3':
                    editor.setTool('delete');
                    break;
                case 'Escape':
                    editor.cancelCurrentOperation();
                    break;
                case 'Delete':
                    if (editor.selectedBone) {
                        editor.skeleton.removeBone(editor.selectedBone.name);
                        editor.selectedBone = null;
                        editor.updateBoneList();
                        editor.render();
                    }
                    break;
            }
        });

        setTimeout(() => {
            try {
                const rootBone = editor.skeleton.addBone('root', 200, 200, 80, 0);
                const childBone1 = editor.skeleton.addBone('arm_upper', 10, 10, 60, Math.PI/4, rootBone);
                const childBone2 = editor.skeleton.addBone('arm_lower', 5, 5, 50, Math.PI/6, childBone1);
                
                editor.updateBoneList();
                editor.render();
                
                document.getElementById('status').textContent = '已載入示例骨架';
            } catch (error) {
                console.error('Error creating example skeleton:', error);
            }
        }, 1000);
    </script>
</body>
</html>
```